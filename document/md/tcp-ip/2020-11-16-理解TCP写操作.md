
##   理解TCP写操作

| 作者 | 时间 |QQ技术交流群 |
| ------ | ------ |------ |
| perrynzhou@gmail.com |2020/11/16 |中国开源存储技术交流群(672152841) |

- TCP的write操作是把用户态的数据拷贝到TCP内核协议栈的缓冲区,并不是把数据发送到对端，也就是说write返回的时候仅仅是用户态到内核态的数据拷贝成功，具体的什么时候数据需要发送是由TCP协议栈的发送窗口和拥塞窗口决定

- TCP发送数据策略的主要目标之一就是充分的利用可用带宽,为了达到这个目标TCP更倾向于以MSS尺寸的块来发送数据。在TCP连接过程中,TCP连接的每一端都可以指定它愿意接受的MSS，其对等实体必须遵循这个约定，也不能发送超过MSS尺寸的段，这个是有发送窗口决定。

- 拥塞控制是一个非常重要的问题，如果TCP突然要将大量TCP段传入网络中去，路由器缓冲区将会被耗尽，造成数据报的丢失,会造成发送端重传，从而进一步加剧网络的拥塞。在极端情况下，网络会变得非常的拥塞，以至于只能传送很少、或者无法传送数据报，此时就出现了拥塞崩溃。为了避免出现拥塞,TCP不会突然同时向空闲连接上发送第一个段，相反，开始它会发送一个段，然后增加网络中未经确认的段的数量，直到达到一个稳定的状态为止。

- TCP使用两种算法来控制拥塞，这两种方法都使用了拥塞窗口来控制拥塞，TCP在任意时刻能够发送的最大数据量是发送窗口和拥塞窗口的中的最小值。这两个窗口负责的是流量控制的不同方面，发送窗口是由对等TCP实体控制，防止我们发送的数据十对等实体接受缓冲区溢出。拥塞窗口由TCP控制，防止我们发送超出网络容量的数据，将数据传输量限制在这两个窗口的最小值内，可以保证实现这两种类型的流量控制。

- TCP的流控算法有两种，一种是慢启动算法,另外一种是拥塞避免算法

  - 慢启动，顾名思义就是慢慢地将向网络发送数据的速率增加到一个阈值。这里的所说的“慢慢地”实际是以指数级别进行，一个段会为每个ACK启动一个拥塞窗口，从段1开始，会生成长度序列为1、2、4、8.....个段的拥塞窗口，当拥塞窗口的长度达到了慢启动的阈值时，慢启动阶段就结束了，有另外一个拥塞避免算法接管

  - 拥塞避免，在拥塞避免过程中，假设连接已进入稳定状态，并不断刺探网络以发现可用状态的额外带宽，在拥塞避免阶段，拥塞窗口是线性开发的，每个往返时间内最多开放一个段。如果出现了拥塞情况，或者网络已经空闲一段时间了，拥塞窗口会减小，可能减小一个固定的段长。

  - 另外一个影响tcp发送策略的是nagle算法,TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。
	
       - Nagle算法的规则（可参考tcp_output.c文件里tcp_nagle_check函数注释）：
  
       ```
       （1）如果包长度达到MSS，则允许发送；
       （2）如果该包含有FIN，则允许发送；
       （3）设置了TCP_NODELAY选项，则允许发送；
       （4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
       （5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
       ```
          - Nagle算法只允许一个未被ACK的包存在于网络，它并不管包的大小，因此它事实上就是一个扩展的停-等协议，只不过它是基于包停-等的，而不是基于字节停-等的。Nagle算法完全由TCP协议的ACK机制决定，这会带来一些问题，比如如果对端ACK回复很快的话，Nagle事实上不会拼接太多的数据包，虽然避免了网络拥塞，网络总体的利用率依然很低。
   - Nagle算法是silly window syndrome(SWS)预防算法的一个半集。接收端SWS避免算法的工作方式是除非缓冲区有了“相当大的增加”，否则就不发布窗口更新报文通知，这个“相当大”定义为一个全尺寸段的增长或者大于窗口最大长度一半的增长。,SWS算法预防发送少量的数据，Nagle算法是其在发送方的实现，而接收方要做的时不要通告缓冲空间的很小增长，不通知小窗口，除非缓冲区空间有显著的增长。这里显著的增长定义为完全大小的段（MSS）或增长到大于最大窗口的一半。
        
    - 举个例子，一开始client端调用socket的write操作将一个int型数据（称为A块）写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入‘\r\n’（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后），B块才被发送。这里还隐藏了一个问题，就是A块数据的ACK为什么40ms之后才收到？这是因为TCP/IP中不仅仅有nagle算法，还有一个TCP确认延迟机制 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。在我之前的时间中，t大概就是40ms。这就解释了为什么’\r\n’（B块）总是在A块之后40ms才发出。当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置TCP_QUICKACK选项来取消确认延迟。