
## TCP三次握手和四次挥手简单分析

| 作者 | 时间 |QQ技术交流群 |
| ------ | ------ |------ |
| perrynzhou@gmail.com |2020/11/23 |中国开源存储技术交流群(672152841) |

##### 为什么TCP连接需要三次握手?
- 简单的实例场景
  ```
  阶段1.客户端说:你好，服务端，我要建立一个连接
  阶段2.服务端：好的，客户端
  ```
- TCP建立的过程，客户端的状态迁移：closed->sync_sent->established;服务端的状态迁移：closed->listen->syn_revd->established;
  
- 针对以上的情景对话,貌似TCP连接仅仅需要2次连接，但是这里服务端回复给客户端的信息，服务器永远不敢保证客户端能收到。这也说明TCP需要2次连接是不够的
- 在对话2阶段，服务端收到信息仅仅说明客户端发送和服务端接收没有问题，并不能说明客户端接收和服务端发送也没有问题，因此TCP连接需要三次握手。TCP三次握手需要保证发送端和接受端的发送和接受能力是没有问题的。
- TCP三次握手可以保证客户端和服务端对自己的发送和接受能力做了一次确认。第一次，客户端给服务器发送seq=x,无法得知服务端是否收到；第二次，服务端回去seq=y,ack=x=1，这个时候仅仅说明服务端的接受和发送能力没有问题，但是服务器端只知道自己的接受和发送能力没有问题；第三次，客户端在回复ack=y+1时候，服务器端收到自己第二次发送的ack到达客户端，说明客户端的接受能力没有问题。

##### 为什么TCP断开需要四次挥手?

- TCP四次挥手的过程中，客户端的状态迁移:established->fin_wait_1->fin_wait_2->time_wait->closed;服务端的状态迁移过程:established->close_wait->last-ack->closed

- TCP是全双工的，涉及到客户端到服务端的通信同时也包括服务端到客户端的通信，即客户端->服务端、服务端->客户端，这样的一个全双工的通信的链路。连接的任何一端可以处于half-close状态，因此需要TCP四次挥手。

- 简单的场景

  ```
  阶段1.客户端对服务端说：服务器，我要关闭
  阶段2.服务器回复客户端：好的，我知道了
  阶段3.服务器对客户端：客户端，我也要关闭
  阶段4.客户端回复服务端：好的，我也知道了
  ```
  
- 阶段1和阶段2发生以后只能确认客户端到服务端的通信链路关闭了，此时客户端处于fin_wait2状态，服务端处于close_wait状态，服务端到客户端的通信链路没有关闭；阶段3和阶段4发生以后，服务端到客户端的通信链路关闭后，客户端和服务端才会完全处于clsoed的状态

- 如果客户端和服务端同时主动发起了关闭,双方都会处于fin_wait1状态，此时又收到对方的ACK，这时双方都会切换到closing状态，之后一起进入time_wait状态，经过一段时间后彼此都进去closed状态。

##### 为什么一定需要time_wait的阶段?  

- 所谓“连接”是虚拟的，在物理层面是不存在的。这就意味着当双方进入closed阶段后,之前的连接的数据包很有可能在网络上“溜达"，此时如果收到这些"溜达"的数据包，丢弃就可以了，但是连接有可能重新打开。
- 一个连接是有4元组组成，它们分别是客户端IP、客户端Port,服务端的IP，服务端Port。这四元组是TCP连接的唯一标识。连接关闭之后可能重新被打开,这是连接是新的连接，但是用4元组是是无法区分这是新的连接还是之前老的连接。这会导致之前"溜达"的数据包在新连接打开后当做新的数据包，这样一来老的连接的数据包会“串”到新的连接上面，这是不能接受的，于是设计了一个time_wait的阶段。
- 一个连接保持在time_wait状态,在等待2*MSL的时间进入closed状态。MSL是最大段的生命周期，在TCP网络中任何一个数据包在网络逗留的的最长时间为MSL,默认是120s,这也意味着一个数据包必须在MSL时间内，从源端传输到目标端；如果超过这个MSL的时间，中间路由器会丢失这些数据包
- 那为什么等待2*MSL的时间呢，TCP四次挥手中，第四次发送数据包，服务器端是否能收到是不确定的，服务器针对这种情况的的做法是重发第三次的数据包,客户端收到第三次数据包，再次发送第四次的数据包。服务器重发第三次数据包和第四次数据包的传输时间，最长的2MSL，所以要让客户端处于time_wait状态，要等待M2L时间进入closed状态
- 客户端处于time_wait状态，等到M2L时间后进入closed状态;服务端第四次收到ack后，立即进入closed状态；为啥服务端进入time_wait阶段而是立即进入closed状态？本质原因是没有必要，任何一个连接都是一个四元组，同时关联了客户端和服务端，客户端处于time_wait状态后，这个连接需要等待2*MSL时间之后才能被重新启用,这个时候服务端想立即使用时无法实现的。
- 一个连接关闭要到2*MSL时间之后重新使用，如果频繁的创建连接和关闭关连接，最后会导致大量的连接处于time_wait状态，最终会耗尽所有的连接资源，为了避免这个问题，可以采用如下的办法来处理:
  - 缩短time_wait的时间(只能缓解)
  - 不要让服务端主动关闭连接,这样服务器的连接就不会处于time_wait状态
  - 客户端做连接池，复用连接，而不是频繁的创建和关闭连接，http1.1和http2采用这种的思路